# Лабораторная работа #1

## Выданный код

В файле ght.cpp находится заготовка для решения задачи поиска объекта на основе Generalized Hough Transform. Этот код позвволяет найти особые точки, вычислить их дескрипторы и найти соответствия между особыми точками с двух изображений. 

Для поиска особых точек и дескрипторов необходимо создать детектор и дескриптор: 

```
Ptr<FeatureDetector> detector = FeatureDetector::create("ORB");
Ptr<DescriptorExtractor> descriptorExtractor = DescriptorExtractor::create("ORB");
```

В данной работе используется алгоритм ORB, но вы можете использовать другие детекторы и дескрипторы из доступных в OpenCV. При этом, возможно, нужно будет использовать другую дистанцию. 

Для нахождения соответствий предлагается два метода: ratioTest и crossCheck. При ratioTest для каждого дескриптора с первого изображения мы находим два наиболее близких по дистанции дескриптора с другого изображения и смотрим на отношение их дистанций. Если их дистанции отличаются достаточно сильно, считаем что соответствие с минимумом дистанции является правильным.

Метод crossCheck основан на другой идее. Для кажого дескриптора на первом изображении найдем ближайший дескриптор на втором изображении. Пусть для дескриптора p_im1 им будет являться q_im2. Тогда найдем для дескриптора q_im2 ближайший дескриптор на первом изображении. Если им будет являться p_im1, то это соответсвие будем считать верным. Аналогично ratioTest можно каждый раз искать не самый близкий дескриптор, а несколько ближайших. Тогда можем расширить этот алгоритм (см. параметр knn функции crossCheckMatching):
Найдем для p_im1 k ближайших дескрипторов на втором изображении q1_im2, q2_im2, ..., qk_im2.
Для каждого i для qi_im2 найдем k ближайших на первом изображении p1_i_im1, p2_i_im1, ..., pk_i_im1

Если для каких-нибудь индесов i и j pj_i_im1 == p_im1, то считаем соответствие между p_im1 и qi_im2 верным. 

Для каждой особой точки характерен масштаб и угол, в качестве примера работы с ними изучите функцию drawKpt.

Основная логика GHT заключена в следующих строках: 

```
Point center(image.cols / 2, image.rows / 2);
Mat hgt(scene.rows/splitSet, scene.cols/splitSet, CV_32S, Scalar::all(0));

for (int matchInd = 0; matchInd < matches.size(); matchInd++)
{

}
Point maxP;
minMaxLoc(hgt, 0, 0, 0, &maxP, Mat());
Point resultCenter(maxP.x*splitSet, maxP.y*splitSet);
```

Мы находим центр объекта на изображении как геометрический центр. В GHT каждое соответствие голосует за преобразование между изображениями. Рассмотрим упрощенный случай, когда каждое соответствие будет голосовать за положение центра объекта на втором изображении. Для этого введем дискретизацию координат на втором изображении с шагом splitSet. Получим таблицу голосования, где, пока что, в каждой ячейке написан ноль. 

Для каждого соответсвия сделаем следующее:
 - Возьмем соответствующую особую точку на первом изображении (там где только объект)
 - Найдем дистанцию r от нее до центра объекта и угол этого вектора
 - Рассмотрим вторую особую точку, найдем как изменился угол главного градиента delta_a особой точки и масштаб delta_scale=scale2/scale1
 - Найдем новое положение центра объекта на основе этого соответсвия. Дистанция от особой точки до центра объекта на втором изображении должна измениться соответственно изменению масштаба, то есть r2 = r*delta_scale. То есть центр находится на расстояние r2 от особой точки на втором изображении. При этом угол наклона вектора между особой точкой и центром должен поменяться на delta_a.
 - В соответсвующую положению нового центра ячейку матрицы hgt добавим единицу. 

## Задача 1

 - Реализовать вариант GHT на основе выданного кода (ght.cpp)
 - Детали задачи описаны в документе f2dp2.pdf
 - Вам необхоимо просто добавить код в цикл обработки соответствий:
```
for (int matchInd = 0; matchInd < matches.size(); matchInd++)
{
   //add your code here
}
```

## Задача 2

Так как наши объекты плоские, то между их проекциями существует гомография. Поэтому на основе RANSAC метода и найденных соответсвий мы можем ее найти.

 - Реализовать нахождение гомографии на основе соответствий с использованием RANSAC
 ```
Mat hommat = findHomography(srcmat, dstmat, CV_RANSAC, ransacThresh);
```

 - Визуализировать результат, либо преобразовав исходное изображение с помощью найденной матрицы гомографии (_warpPerspective_), либо отрисовав многоугольник, в который перейдет исходное изображение.
